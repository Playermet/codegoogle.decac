Package decasyntax;

Helpers
  unicode_input_character = [0..0xffff];
  letter = ['A'..'Z'] | ['a'..'z'] | [0x7F .. 0xFF];
  digit = ['0'..'9'];
  nondigit = '_' | '?' | '!' | letter;
  all = [0 .. 0xFFFF];
  cr = 13;
  lf = 10;
  tab = 9;
  eol = cr | lf | cr lf;
  input_character = [unicode_input_character - [cr + lf]];
  not_cr_lf = [all - [cr + lf]];
  not_star = [all - '*'];
  not_star_slash = [not_star - '/'];
  
  non_zero_digit = ['1'..'9'];
  hex_digit = ['0'..'9'] | ['a'..'f'] | ['A'..'F'];
  octal_digit = ['0'..'7'];
  zero_to_three = ['0'..'3'];
  decimal_numeral = '0' | non_zero_digit digit*;
  hex_numeral = '0x' hex_digit+;
  octal_numeral = '0' octal_digit+;
  
  single_character = [input_character - ['"' + '\']];
  octal_escape = '\' (octal_digit octal_digit? | zero_to_three octal_digit octal_digit);
  escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\' | octal_escape;
  string_character = single_character | escape_sequence;
  
  at_operator = '@';
  exponentiation_operator = '^';
  
Tokens
  constant = 'constant';
  protected = 'protected';
  boolean_constant = 'true' | 'false';
  multiplication_operator = '*';
  division_operator = '/';
  addition_operator = '+';
  subtraction_operator = '-';
  and_operator = 'and';
  or_operator = 'or';
  xor_operator = 'xor';
  minus_operator = '-';
  exponentiation_operator = '^';
  at_operator = '@';
  not_operator = 'not';
  generic = 'generic';
  method = 'method';
  comma = ',';
  assignment_operator = ':=';
  lparen = '(';
  rparen = ')';
  lbracket = '{';
  rbracket = '}';
  lsbracket = '[';
  rsbracket = ']';
  dot = '.';
  semicolon = ';';
  end = 'end';
  module = 'module';
  labracket = '<';
  rabracket = '>';
  import = 'import';
  define = 'define';
  new = 'new';
  delete = 'delete';
  constructor = 'constructor';
  destructor = 'destructor';
  extends = 'extends';
  class_keyword = 'class';
  subrange = 'subrange';
  enum = 'enum';
  exception = 'exception';
  equals = '=';
  different = '<>';
  greatereq = '>=';
  lessereq = '<=';
  function = 'function';
  while = 'while';
  do = 'do';
  for = 'for';
  case = 'case';
  cond = 'cond';
  let = 'let';
  except = 'except';
  finally = 'finally';
  try = 'try';
  throw = 'throw';
  else = 'else';
  type = 'type';
  null_literal = 'null';
  underscore = '_';
  arrow_operator = '->';
  region = 'region';
  region_combining_operator = '++';
  typesize = 'typesize';
  sizeof = 'sizeof';
  
  blank = eol | tab | ' ';
  tabspace = [tab + ' '];
  space = [cr + [lf + [tab + ' ']]];
  comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  unqualified_identifier = nondigit (digit | nondigit)*;
  integer_constant = decimal_numeral | hex_numeral | octal_numeral;
  string_constant = '"' string_character* '"';

Ignored Tokens

  blank,
  comment;
  
Productions
  module_definition = 
    module [name]:unqualified_identifier [imports]:import_declaration* [definitions]:definition* end;

  qualified_identifier = 
    {simple} unqualified_identifier |
    {imported} qualified_identifier dot unqualified_identifier;

  identifier_list = {one} unqualified_identifier | {many} identifier_list comma unqualified_identifier;
    
  import_declaration = 
    import [name]:qualified_identifier;
    
  subrange_bound = 
    {integer} integer_constant |
    {enum} unqualified_identifier;
    
  type_form =
    {function} function_type_form |
    {alias} at_operator nullable_alias_clause? lower_type_form  |
    {class} class_keyword [parameters]:type_form_arguments? [extension]:extension_clause? lbracket [member]:member_declaration+ rbracket |
    {subrange} subrange lparen [floor]:subrange_bound comma [ceiling]:subrange_bound rparen [parent]:extension_clause |
    {enum} enum lparen identifier_list rparen [extension]:extension_clause? |
    {exception} exception lparen identifier_list rparen [extension]:extension_clause? |
    {others} lower_type_form;
    
  function_type_form = 
    {one} [argument]:lower_type_form arrow_operator [result]:type_form |
    {many} lparen [arguments]:type_form_list rparen arrow_operator [result]:type_form;
  
  lower_type_form =
    {named} [typename]:qualified_identifier [arguments]:type_form_arguments? |
    {parenthetical} type lparen type_form rparen |
    {tuple} lsbracket typed_variable_declaration_list rsbracket |
    {array} lower_type_form lsbracket integer_constant rsbracket |
    {region} region |
    {wildcard} underscore |
    {bottom} null_literal;

  nullable_alias_clause =
    null_literal or_operator;
      
  definition = 
    {globaldef} define constant? typed_variable_assignment |
    {typedef} type [name]:unqualified_identifier assignment_operator type_form |
    {moduledef} module_definition |
    {fundef} function_definition;
  
  type_form_arguments =
    labracket [arguments]:type_form_list rabracket;  

  type_form_list = 
    {one} type_form |
    {many} type_form_list comma type_form;

  typed_variable_declaration =
    [name]:unqualified_identifier [type]:type_form;
    
  typed_variable_declaration_list = 
    {one} typed_variable_declaration |
    {many} typed_variable_declaration_list comma typed_variable_declaration;
    
  typed_variable_assignment =
    typed_variable_declaration assignment_operator expression;
    
  member_declaration = 
    {named} protected? [names]:identifier_list [type]:type_form semicolon;
    
  extension_clause = 
    extends [supertype]:qualified_identifier [arguments]:type_form_arguments?;
    
  argument =
    {generic} unqualified_identifier |
    {typed} typed_variable_declaration;
    
  argument_list = 
    {one} argument |
    {many} argument_list comma argument;
    
  function_definition = 
    {generic} generic [type]:type_form [name]:unqualified_identifier lparen [arguments]:argument_list rparen [body]:block_expression |
    {method} method [name]:qualified_identifier lparen [arguments]:argument_list rparen [body]:block_expression |
    {function} function [name]:unqualified_identifier lparen [arguments]:argument_list rparen [body]:block_expression |
    {constructor} new [type]:qualified_identifier lparen [arguments]:argument_list rparen [body]:block_expression |
    {destructor} delete [type]:qualified_identifier lparen [arguments]:argument_list rparen [body]:block_expression;
    
  expression =
    {assignmentexp} qualified_identifier assignment_operator expression |
    {letexp} let_expression |
    {tryexp} try [attempt]:expression [exceptions]:except_expression_clause* finally [finalizer]:expression |
    {forexp} for lparen [initializer]:let_assignment [first_separator]:semicolon [test]:expression [second_separator]:semicolon [step]:expression rparen [loop]:expression |
    {whilexp} while lparen [condition]:expression rparen [body]:expression |
    {doexp} do [body]:expression while lparen [condition]:expression rparen |
    {throwexp} throw expression |
    {condexp} cond_expression |
    {blockexp} block_expression |
    {regionexp} region lsbracket integer_constant rsbracket |
    {others} exp5;
    
  sizeof_expression =
    {type} typesize lparen type_form rparen |
    {expression} sizeof lparen expression rparen;
    
  //Increasing precedence levels.
  exp1 =   
    {at} at_operator [variable]:qualified_identifier |
    {sizeof} sizeof_expression |
    {primitive} primitive_expression |
    {tuple} lsbracket expression_list rsbracket |
    {lambda} function lparen argument_list rparen block_expression [region]:parenthetical_expression? |
    {call} function_call_expression |
    {parenthetical} parenthetical_expression |
    {identifier} qualified_identifier;
  
  exp2 = 
    {exponentiation} [exp1]:exp1 exponentiation_operator [exp2]:exp2 |
    {minus} minus_operator exp2 |
    {not} not_operator exp2 |
    {others} exp1;
  
  exp3 = 
    {and}  [exp1]:exp3 and_operator [exp2]:exp2 |
    {or}  [exp1]:exp3 or_operator [exp2]:exp2 |
    {xor}  [exp1]:exp3 xor_operator [exp2]:exp2 |
    {multiply} [exp1]:exp3 multiplication_operator [exp2]:exp2 |
    {division} [exp1]:exp3 division_operator [exp2]:exp2 |
    {others} exp2;
    
  exp4 =
    {plus} [exp1]:exp4 addition_operator [exp2]:exp3 |
    {minus} [exp1]:exp4 subtraction_operator [exp2]:exp3 |
    {regions} [exp1]:exp4 region_combining_operator [exp2]:exp3 |
    {others} exp3;
    
  exp5 = 
    {greater} [exp1]:exp4 rabracket [exp2]:exp4 |
    {greatereq} [exp1]:exp4 greatereq [exp2]:exp4 |
    {less} [exp1]:exp4 labracket [exp2]:exp4 |
    {lessereq} [exp1]:exp4 lessereq [exp2]:exp4 |
    {equals} [exp1]:exp4 equals [exp2]:exp4 |
    {different} [exp1]:exp4 different [exp2]:exp4 |
    {others} exp4;
    
  function_call_expression =
    {variable} [function]:qualified_identifier lparen [arguments]:expression_list? rparen |
    {parens} [function]:parenthetical_expression lparen [arguments]:expression_list? rparen |
    {constructor} new [type]:qualified_identifier lparen [arguments]:expression_list? rparen |
    {destructor} delete [type]:qualified_identifier lparen [arguments]:expression_list? rparen;
  
  parenthetical_expression =
    lparen expression rparen;
    
  primitive_expression = 
    {integer} integer_constant |
    {boolean} boolean_constant |
    {string} string_constant |
    {null} null_literal;
    
  expression_list = 
    {one} expression |
    {many} expression_list comma expression;
  
  except_expression_clause =
    except lparen typed_variable_declaration rparen expression;
  
  case_expression_clause =
    case lparen [condition]:expression rparen [body]:expression;
    
  cond_expression =
    {one} cond [case]:case_expression_clause |
    {many} cond lbracket [cases]:case_expression_clause+ rbracket;
    
  let_assignment = 
    unqualified_identifier assignment_operator expression;
    
  let_assignment_list = 
    {one} let_assignment |
    {many} let_assignment_list semicolon let_assignment;
  
  let_expression =
    {let} let lparen let_assignment_list rparen [success]:expression |
    {match} let lparen typed_variable_assignment rparen [success]:expression else [failure]:expression;
    
  block_contents =
    {one} expression semicolon |
    {many} block_contents expression [terminator]:semicolon;
  	
  block_expression =
    lbracket block_contents rbracket;
