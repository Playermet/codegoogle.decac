Package decasyntax;

Helpers
  unicode_input_character = [0..0xffff];
  letter = ['A'..'Z'] | ['a'..'z'] | [0x7F .. 0xFF];
  digit = ['0'..'9'];
  nondigit = '_' | '?' | '!' | letter;
  all = [0 .. 0xFFFF];
  cr = 13;
  lf = 10;
  tab = 9;
  eol = cr | lf | cr lf;
  input_character = [unicode_input_character - [cr + lf]];
  not_cr_lf = [all - [cr + lf]];
  not_star = [all - '*'];
  not_star_slash = [not_star - '/'];
  
  non_zero_digit = ['1'..'9'];
  hex_digit = ['0'..'9'] | ['a'..'f'] | ['A'..'F'];
  octal_digit = ['0'..'7'];
  zero_to_three = ['0'..'3'];
  decimal_numeral = '0' | non_zero_digit digit*;
  hex_numeral = '0x' hex_digit+;
  octal_numeral = '0' octal_digit+;
  
  single_character = [input_character - ['"' + '\']];
  octal_escape = '\' (octal_digit octal_digit? | zero_to_three octal_digit octal_digit);
  escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\' | octal_escape;
  string_character = single_character | escape_sequence;
  
  at_operator = '@';
  caret = '^';
  
Tokens
  var = 'var';
  protected = 'protected';
  boolean_constant = 'true' | 'false';
  asterisk = '*';
  division_operator = '/';
  addition_operator = '+';
  subtraction_operator = '-';
  exponentiation_operator = '**';
  and_operator = 'and';
  or_operator = 'or';
  xor_operator = 'xor';
  minus_operator = '-';
  caret = '^';
  at_operator = '@';
  not_operator = 'not';
  method = 'method';
  override = 'override';
  comma = ',';
  assignment_operator = ':=';
  lparen = '(';
  rparen = ')';
  lbracket = '{';
  rbracket = '}';
  lsbracket = '[';
  rsbracket = ']';
  dot = '.';
  semicolon = ';';
  colon = ':';
  double_colon = '::';
  end = 'end';
  module = 'module';
  unsafe = 'unsafe';
  labracket = '<';
  rabracket = '>';
  import = 'import';
  define = 'define';
  extends = 'extends';
  class_keyword = 'class';
  variant_keyword = 'variant';
  exception = 'exception';
  destructor = 'destructor';
  equals = '=';
  different = '<>';
  greatereq = '>=';
  lessereq = '<=';
  function = 'function';
  while = 'while';
  do = 'do';
  for = 'for';
  case = 'case';
  if = 'if';
  then = 'then';
  let = 'let';
  except = 'except';
  finally = 'finally';
  try = 'try';
  throw = 'throw';
  else = 'else';
  type = 'type';
  underscore = '_';
  firstclass_function_arrow = '->';
  function_pointer_arrow = '@->';
  evaluation_arrow = '=>';
  sizeof = 'sizeof';
  match = 'match';
  return = 'return';
  cast = 'cast';
  interface = 'interface';
  
  blank = eol | tab | ' ';
  tabspace = [tab + ' '];
  space = [cr + [lf + [tab + ' ']]];
  comment = '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  unqualified_identifier = nondigit (digit | nondigit)* | 'exception';
  integer_constant = decimal_numeral | hex_numeral | octal_numeral;
  string_constant = '"' string_character* '"';

Ignored Tokens

  blank,
  comment;
  
Productions
  module_definition = 
    unsafe? module [name]:unqualified_identifier [imports]:import_declaration* [definitions]:definition* end;

  qualified_identifier = 
    {simple} unqualified_identifier |
    {imported} qualified_identifier double_colon unqualified_identifier;

  identifier_list = {one} unqualified_identifier | {many} identifier_list comma unqualified_identifier;
    
  import_declaration = 
    import [name]:qualified_identifier;
    
  variant_case_contents = lparen tuple_component_list rparen;
    
  variant_component = 
    unqualified_identifier variant_case_contents?;
    
  gathering_component =
    qualified_identifier variant_case_contents?;
    
  existential_form =
    interface labracket unqualified_identifier rabracket type_form;
    
  type_form =
    {function} function_type_form |
    {scoped_pointer} lower_type_form asterisk |
    {pointer} at_operator lower_type_form |
    {variant} variant_keyword lbracket variant_component+ rbracket |
    {gathering} variant_keyword extends lbracket gathering_component+ rbracket |
    {existential} existential_form |
    {class} class_keyword function_arguments? class_extension_clause? lbracket [member]:member_declaration+ destructor_definition? rbracket |
    {exception} exception variant_case_contents [extension]:extension_clause? |
    {others} lower_type_form;
  
  destructor_definition = destructor [body]:block_expression;
  
  function_arguments_type_form = type_form comma type_form_list;
  
  type_arrow =
    {closure} firstclass_function_arrow |
    {pointer} function_pointer_arrow;
    
  function_type_form = 
    {one} [argument]:lower_type_form type_arrow [result]:type_form |
    {many} lparen function_arguments_type_form? rparen type_arrow [result]:type_form;
    
  recursive_type_naming =
    let [name]:unqualified_identifier equals;
    
  tuple_component =
    {type} type_form |
    {binding} [name]:unqualified_identifier type_annotation;
    
  tuple_component_list = 
    {one} tuple_component |
    {many} tuple_component_list comma tuple_component;
    
  tuple_form = 
    lsbracket tuple_component_list rsbracket;
    
  type_parameterization = labracket [arguments]:type_form_list rabracket;
  
  lower_type_form =
    {named} [typename]:qualified_identifier type_parameterization? |
    {parenthetical} recursive_type_naming? lparen type_form rparen |
    {tuple} tuple_form |
    {array} lower_type_form lsbracket integer_constant? rsbracket |
    {wildcard} underscore;
      
  definition = 
    {globaldef} define var? unqualified_identifier type_annotation? assignment_operator expression |
    {extglobaldef} define var? import unqualified_identifier type_annotation |
    {typedef} type unqualified_identifier [parameters]:type_form_arguments? equals type_form |
    {moduledef} module_definition |
    {fundef} function_definition |
    {pooldef} define unqualified_identifier colon lsbracket integer_constant rsbracket;
  
  type_form_arguments =
    labracket [arguments]:identifier_list rabracket;  

  type_form_list = 
    {one} type_form |
    {many} type_form_list comma type_form;
    
  type_annotation =
    colon [type]:type_form;
    
  member_declaration = 
    {named} protected? let_assignment_list semicolon;
    
  extension_clause = 
    extends lower_type_form;
    
  class_extension_clause =
    extends lower_type_form function_arguments?;
    
  argument =
    [name]:unqualified_identifier [type]:type_annotation?;
    
  argument_list = 
    {one} argument |
    {many} argument_list comma argument;
    
  function_arguments = lparen [arguments]:argument_list? rparen;
    
  function_definition = 
    {method} method [name]:unqualified_identifier type_form_arguments? function_arguments [type]:type_annotation [body]:block_expression |
    {override} override [name]:qualified_identifier function_arguments [body]:block_expression |
    {function} function [name]:unqualified_identifier type_form_arguments? function_arguments [type]:type_annotation? [body]:block_expression |
    {external} import function [name]:unqualified_identifier function_arguments [type]:type_annotation;
    
  expression =
    {assignmentexp} exp1 assignment_operator expression |
    {letexp} let lparen let_assignment_list rparen expression |
    {matchexp} match_expression |
    {tryexp} try_expression |
    {finalexp} finally [finalizer]:expression |
    {forexp} for lparen [initializer]:let_assignment [first_separator]:comma [test]:expression [second_separator]:comma [step]:expression rparen [loop]:expression |
    {whilexp} while [condition]:expression do [body]:expression |
    {throwexp} throw expression |
    {ifwithoutelseexp} if [condition]:expression then [thenbody]:expression |
    {ifwithelseexp} if [condition]:expression then [thenbody]:expression_with_else else_clause |
    {blockexp} block_expression |
    {returnexp} return expression |
    {packexp} existential_form assignment_operator expression |
    {unpack} match unqualified_identifier colon existential_form assignment_operator expression block_expression |
    {others} exp5;
    
  expression_with_else =
    {assignmentexp} exp1 assignment_operator expression_with_else |
    {letexp} let lparen let_assignment_list rparen expression_with_else |
    {matchexp} match_with_else |
    {tryexp} try_expression_with_else |
    {finalexp} finally [finalizer]:expression_with_else |
    {forexp} for lparen [initializer]:let_assignment [first_separator]:comma [test]:expression [second_separator]:comma [step]:expression rparen [loop]:expression_with_else |
    {whilexp} while [condition]:expression do [body]:expression_with_else |
    {throwexp} throw expression_with_else |
    {ifwithelseexp} if [condition]:expression then [thenbody]:expression_with_else else [elsebody]:expression_with_else |
    {blockexp} block_expression |
    {returnexp} return expression_with_else |
    {packexp} existential_form assignment_operator expression_with_else |
    {unpack} match unqualified_identifier colon existential_form assignment_operator expression block_expression |
    {others} exp5;
    
  literal_expression =
    {integer} integer_constant |
    {boolean} boolean_constant |
    {string} string_constant;
    
  lambda_arguments =
    {one} argument |
    {many} lparen argument comma argument_list rparen;
    
  member_selector = {name} unqualified_identifier | {index} lsbracket integer_constant rsbracket;
  
  //Increasing precedence levels.
  exp1 =
    {at} at_operator [variable]:qualified_identifier |
    {sizeof} sizeof lparen type_form rparen |
    {literal} literal_expression |
    {tuple} lsbracket expression_list rsbracket |
    {lambda} lambda_arguments evaluation_arrow block_expression |
    {call} function_call_expression |
    {cast} cast labracket type_form rabracket lparen expression rparen |
    {parenthetical} parenthetical_expression |
    {identifier} qualified_identifier |
    {field} exp1 dot member_selector |
    {dereference} exp1 caret;
  
  exp2 = 
    {exponentiation} [exp1]:exp1 exponentiation_operator [exp2]:exp2 |
    {minus} minus_operator exp2 |
    {not} not_operator exp2 |
    {others} exp1;
  
  exp3 = 
    {and}  [exp1]:exp3 and_operator [exp2]:exp2 |
    {or}  [exp1]:exp3 or_operator [exp2]:exp2 |
    {xor}  [exp1]:exp3 xor_operator [exp2]:exp2 |
    {multiply} [exp1]:exp3 asterisk [exp2]:exp2 |
    {division} [exp1]:exp3 division_operator [exp2]:exp2 |
    {others} exp2;
    
  exp4 =
    {plus} [exp1]:exp4 addition_operator [exp2]:exp3 |
    {minus} [exp1]:exp4 subtraction_operator [exp2]:exp3 |
    {others} exp3;
    
  exp5 = 
    {greater} [exp1]:exp4 rabracket [exp2]:exp4 |
    {greatereq} [exp1]:exp4 greatereq [exp2]:exp4 |
    {less} [exp1]:exp4 labracket [exp2]:exp4 |
    {lessereq} [exp1]:exp4 lessereq [exp2]:exp4 |
    {equals} [exp1]:exp4 equals [exp2]:exp4 |
    {different} [exp1]:exp4 different [exp2]:exp4 |
    {others} exp4;
    
  function_call_expression =
    {variable} [function]:qualified_identifier lparen [arguments]:expression_list? rparen |
    {parens} [function]:parenthetical_expression lparen [arguments]:expression_list? rparen;
    
  except_case_clause =
    case [name]:unqualified_identifier type_annotation evaluation_arrow [body]:expression;
    
  except_case_clause_with_else =
    case [name]:unqualified_identifier type_annotation evaluation_arrow [body]:expression_with_else;
    
  try_expression = 
    {one} try expression except except_case_clause |
    {many} try expression except lbracket except_case_clause+ rbracket;
    
  try_expression_with_else =
    {one} try expression except except_case_clause_with_else |
    {many} try expression except lbracket except_case_clause+ rbracket;
  
  parenthetical_expression =
    lparen expression rparen;
    
  expression_list = 
    {one} expression |
    {many} expression_list comma expression;
    
  else_clause = 
    else [else_body]:expression;
    
  let_assignment =
    unqualified_identifier type_annotation? assignment_operator expression;

  let_assignment_list = 
    {one} let_assignment |
    {many} let_assignment_list comma let_assignment;
    
  pattern_list = 
    {one} match_pattern |
    {many} pattern_list comma match_pattern;
    
  pattern_variable = {some} unqualified_identifier | {none} underscore;
    
  match_pattern = 
    {literal} literal_expression |
    {variable} [name]:pattern_variable type_annotation? |
    {variant} [name]:qualified_identifier lparen pattern_list? rparen |
    {tuple} lsbracket pattern_list rsbracket;
    
  match_case_clause = case [pattern]:match_pattern evaluation_arrow [body]:expression;
  
  match_expression = 
    match lparen expression rparen lbracket match_case_clause+ rbracket else_clause?;
  
  match_with_else = 
    match lparen expression rparen lbracket match_case_clause+ rbracket else expression_with_else;
    
  block_steps_list =
    {one} expression semicolon |
    {many} expression semicolon block_steps_list;
    
  block_contents =
    {one} expression |
    {many} expression semicolon block_steps_list;
  	
  block_expression =
    lbracket block_contents rbracket;
